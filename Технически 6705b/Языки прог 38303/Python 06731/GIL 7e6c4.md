# GIL

## Ссылки

1. Глобальная блокировка интерпретатора (GIL) и её воздействие на многопоточность в Python (2021);

[Глобальная блокировка интерпретатора (GIL) и её воздействие на многопоточность в Python](https://habr.com/ru/company/wunderfund/blog/586360/)

1. GIL и его влияние на многопоточность Python (2021).

[GIL и его влияние на многопоточность Python](https://habr.com/ru/post/592189/)

## Что такое GIL?

**GIL**- глобальная блокировка интерпретатора, обеспечивает безопасную работу с потоками в [CPython](https://ru.wikipedia.org/wiki/CPython). По факту, в системе работает лишь один поток, вне зависимости от возможностей.

GIL позволяет только одному потоку ОС выполнять байт-код Python в любой момент времени. Следствием этого является невозможность ускорить выполнение кода Python с интенсивным использованием процессора путем распределения работы между несколькими потоками.

В однопоточной программе главный поток является единственным.

Основной поток - обычный поток операционной системы, который, в данном случае, выполняет скомпилированный код на С. Однако, он должен захватить стек вызова функций Python, состояние исключений и т.д.

Другими словами, Python thread = OS thread + Python thread state.

### Процесс запуска исполняемого файла

1. Запуск нового процесса с одним вычислительным потоком;
2. Инициализация интерпретатора;
3. Компилирует код Python в байт- код;
4. Вход в вычислительный цикл для выполнения байт-кода.

## Работа GIL, если программа многопоточная

Поток, прежде чем перехватить GIL, проверяет, занят ли он другим потоком. Если GIL свободен, поток сразу же его захватит. Если нет, будет ожидание в 5мс, и если GIL не будет отпущен в течение этого времени, поток устанавливает флаги `eval_breaker` и `gil_drop_request`.

- Флаг `eval_breaker` указывает потоку, удерживающему GIL, приостановить
выполнение байт- кода;
- Флаг `gil_drop_request` объясняет, почему потоку, удерживающему GIL, нужно его
отпустить.

### Когда GIL может быть отпущен потоком?

Для того,что бы позволить другому потоку выполнить код в то время, как другой поток,
удерживающий GIL, ожидает выполнения операции ввода вывода, есть следующий
паттерн:

1. Освобождение GIL;
2. Выполнение операции i/o;
3. Захват GIL.

Другие моменты, которые могут освободить GIL:

1. C-функции (некоторые), например хеш функция;
2. Сторонние функции, где это реализовано ([NumPy](https://ru.wikipedia.org/wiki/NumPy));
3. Самописец расширения освобождения GIL.

## Где полезно использование потоков?

Использование потоков Python может быть полезно, если выполняется множество операций, производительность которых привязана к системе ввода/вывода.

## Проблемы, которые могут возникнуть из-за GIL

1. Использование многопоточности там, где это не нужно;
    
    Основная проблема - невозможность параллельного выполнения программы.
    Многопоточные программы работают не быстрее, чем на одном потоке.
    
    | Кол-во потоков | Кол-во операций | Время выполнения |
    | --- | --- | --- |
    | 1 | 100 000 000 | 6.52 |
    | 2 | 50 000 000 | 6.57 |
    | 4 | 25 000 000 | 6.59 |
    | 8 | 12 500 000 | 6..61 |
2. Эффект сопровождения (конвоя);
    
    Связан с тем, когда поток ограниченный операцией i/o, выполняет ее, освобождая GIL. После этой операции поток снова пытается взять gil, вероятно, он уже будет захвачен другим потоком. Придется ждать 5мс, что для быстрых операций i/o может быть критичной просадкой (`send` с полным буфером отправки).
    
    Можно попробовать исправить с помощью уменьшения интервала переключения. Но, делать этот интервал очень маленьким тоже не стоит, будут проявлятся накладные расходы на переключение.
    

## Где используется GIL

1. Подсчёт ссылок на объекты;
2. Работа с мутабельными структурами данных;
3. Глобальные данны и данные интерпретатора (загруженные модули,
интернированные строки);
4. C-расширения;

## Mutex

**Mutex** - простая блокировка, взаимосключение. Простейшая блокировка, которая на
время работы потока с каким либо рисурсом закрывает этот ресурс от других
обращений. Реализовать можно с помощью класса `Lock` из библиотеки `threading`.

- `.acquire()` - установка на блокировку;
- `.release()` - снятие с блокировки.

```python
from threading import Thread, Lock

mutex = Lock()

def processData(data):
    mutex.acquire()
    try:
        print('Do some stuff')
    finally:
        mutex.release()

while True:
    t = Thread(target = processData, args = (some_data,))
    t.start()
```