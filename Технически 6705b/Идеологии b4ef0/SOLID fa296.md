# SOLID

## Ссылки

1. SOLID (2018);

[SOLID](https://habr.com/ru/post/348286/)

1. Принципы SOLID, о которых должен знать каждый разработчик (2018).

[Принципы SOLID, о которых должен знать каждый разработчик](https://medium.com/webbdev/solid-4ffc018077da)

## Рамки, в которых может существовать SOLID

***SOLID*** всегда упоминают в контексте ООП. Так получилось, что именно в ООП языках появилась удобная и безопасная поддержка динамического полиморфизма. Фактически, в контексте ***SOLID*** под ООП понимается именно динамический полиморфизм.

Полиморфизм дает возможность для разных типов использовать один код.Полиморфизм можно грубо разделить на динамический и статический.

- Динамический полиморфизм — это про абстрактные классы, интерфейсы, утиную типизацию, т.е. только в рантайме будет понятно, с каким типом будет работать наш код;
- Статический полиморфизм — это в основном про шаблоны (genererics). Когда уже на этапе компиляции из одного шаблонного кода генерируется код специфичный для каждого используемого типа.

Кроме привычных языков вроде Java, C#, Ruby, JavaScript, динамический полиморфизм реализован, например в

- Golang, с помощью интерфейсов;
- Clojure, с помощью протоколов и мультиметодов;
- в прочих, совсем не “ООП” языках.

## Принципы

***SOLID*** принципы советуют, как проектировать модули, т.е. кирпичики, из которых строится приложение. Цель принципов — проектировать модули, которые:

- способствуют изменениям;
- легко понимаемы;
- повторно используемы.

### S: Single Responsibility Principle - принцип единственной ответственности

Один класс должен быть ответственнен только за одно логическое действие. Если класс делает что- то ещё, то изменение частей, которые реализуют такие функции, связанны со всем остальным. Их изменение влечет к изменениям всего класса

### O: Open- Closed Principle - Принцип открытости-закрытости

Появление подклассов не должно затрагивать изменение родительского класса. Как пример, класс животных не должен заниматься логикой звуков животных (подклассов), которые с этим родительским классом могут быть связанны.

### L: Liskov Substitution Principle - Принцип подстановки Барбары Дисков

Стоит уходить от любой логики, которая включает в себя работу на основе типа аргумента (сравнение по типу).

### I: Interface Segregation Principle - Принцип разделения интерфейсов

Принцип разделения интерфейсов: интерфейс должен заниматься только своей задачей, причем клиенты не должны зависит от от интерфейсов, которые не используют.

### D: Dependency Inversion Principle - Принцип инверсии зависимостей

Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба они должны зависить от абстракции.
Сами абстракции не должны зависить от деталей. Нарушения принципа не позволит создания модульности прирасширении проекта.