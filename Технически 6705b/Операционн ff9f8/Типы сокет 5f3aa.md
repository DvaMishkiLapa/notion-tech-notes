# Типы сокетов

## Ссылки

1. select / poll / epoll: практическая разница (2018).

[select / poll / epoll: практическая разница](https://habr.com/ru/company/infopulse/blog/415259/)

## Блокирующие и неблокирующие сокеты

Сокеты бывают блокирующие и не блокирующие:

- Блокирующие
При попытке прочитать или записать данные, функция чтения будет жать чтения хотя бы одного байта или произойдет разрыв соеденения или будет сигнал разрыва.
- Неблокирующие
Неблокирующие сокеты проверяют, есть ли данные в буфере и, если есть - сразу возвращают. Если данных нет, то без ожидания будет возвращено 0 байт информации.

## Виды сокетов

### `Select()`

Разрабатывался в те времена, когда не предпологалось, что развитие уйдет в многопоточность. Старый метод, давольно сложный в использовании. Его использование на сегодняшний день обусловлено двумя фактами:

1. Портируемость `Select()`. Он есть практически на всем. Как пример, Windows XP, где нет `poll`, а `Select()` есть;
2. Возможность работы с таймаутами порядка одной наносекунды, если это позволяет аппаратная часть.

### `Poll()`

Появился после того, как люди начали писать большие и высоконагруженные сетевые сервисы. В основном, был создан для решения проблем, которые были у `Select()`.

Плюсы:

1. Нет лимита наблюдаемых дескрипторов, можно мониторить более 1024 штук;
2. В процессе работы не модифицируется структура `pollfd`, что дает возможность ее
переиспользования между вызовами `poll()`;
3. Лучшая структурированность, например, можно определить отключение
удаленного клиента без чтения данных.

Минусы:

1. Есть не на всех платформах;
2. Точность таймаута - 1 мс, если сравнивать с `Select()`;
3. Невозможно понять, какие именно дискрипторы сгенерировали события, без
полного прохода по ним;
4. Нет возможности менять наблюдаемый набор событий.

### `Epoll()`

Новейший и лучший метод ожидания в Linux. Предоставляет API для добавления, удаления, модификации списка наблюдаемых дискрипторов и событий.

Плюсы:

1. `epoll()` возвращает список тех дескриптеров, для которых произошли наблюдаемые
события. Не нужно просматривать тысячи структур для поиска нужной;
2. Можно ассоциировать некоторый значимый контекст с каждым наблюдаемым
событием;
3. Возможно добавлять и удалять сокеты из списка в любой момент;
4. Можно завести сразу несколько потоков, ожидающих события из одной и той же
очереди.

Минусы:

1. Изменение флагов событий (например, переключение с `READ` на `WRITE`) требует
лишнего системного вызова `epoll_ctl`. В `poll()` просто меняется битовая маска;
2. Для каждого нового соединения придется вызвать `accept()` и `epoll_ctl()` - два
системных вызова. У `poll()` он лиш один. При коротком времени соединения это
может играть роль;
3. `epoll()` есть только в Linux;
4. Трудности написания парралельного высоконагруженного кода.

### libevent

Библиотека, которая оборачивает методы опроса (в том числе, что выше), в унифицированное API.

Позволяет запускать один и тот же код на разных операционных системах.

Не решает проблемы используемого метода опроса.