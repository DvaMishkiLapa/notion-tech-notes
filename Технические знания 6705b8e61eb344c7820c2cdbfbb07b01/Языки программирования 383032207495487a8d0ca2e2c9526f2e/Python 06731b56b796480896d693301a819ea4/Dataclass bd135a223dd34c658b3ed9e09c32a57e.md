# Dataclass

## Ссылки

1. ****Введение в Data classes (2018).****

[Введение в Data classes](https://habr.com/ru/post/415829/)

1. **dataclasses — Data Classes**

[dataclasses - Data Classes - Python 3.10.4 documentation](https://docs.python.org/3/library/dataclasses.html)

## Зачем нужны `Dataclass`?

Они призваны автоматизировать генерацию кода классов, которые используются для хранения данных.

Не смотря на то, что они используют другие механизмы работы, их можно сравнить с "изменяемыми именованными кортежами со значениями по умолчанию".

`Dataclass` появились в [Python 3.7](https://www.python.org/downloads/release/python-370/).

## Примеры использования

`Dataclass` призваны упращать подобные ситуации:

```python
class RegularBook:
    def __init__(self, title, author):
        self.title = title
        self.author = author
```

Уже на этом примере видна избыточность. Идентификаторы `title` и `author` используются несколько раз. Реальный класс же будет ещё содержать переопределенные методы `__eq__` и `__repr__`.

Модуль `dataclasses`содержит декоратор `@dataclass`. С его использованием аналогичный код будет выглядеть так:

```python
from dataclasses import dataclass

@dataclass
class Book:
    title: str
    author: str
```

## Особенности

### Аннотации типов

[Аннотации типов](https://peps.python.org/pep-0526/) **обязательны**. Все поля, которые не имеют отметок о типе будут проигнорированы. Конечно, если вы не хотите использовать конкретный тип, вы можете указать `Any` из модуля `typing`.

### `__init__`, `__repr__`, `__str__` и `__eq__`

После создания `Dataclass` методы `__init__`, `__repr__`, `__str__` и `__eq__` уже реализованы.

### Значения по умолчанию

Одна из полезных особенностей - легкость добавления к полям значений по умолчанию. Все ещё не требуется переопределять метод `__init__`, достаточно указать значения прямо в классе. Они будут учтены в сгенерированном методе `__init__`:

```python
@dataclass
class Book:
    title: str = "Unknown"
    author: str = "Unknown author"
```

Важно следить за порядком определения полей, имеющих значения по умолчанию, так как он в точности соответствует их порядку в методе `__init__`.

### Иммутабельные классы данных

Можно указать параметр `frozen=True` при создании класса и если вы попытаетесь изменять его поля, выбросится исключение `FrozenInstanceError`:

```python
@dataclass(frozen=True)
class Book:
    title: str
    author: str

#-------------------------------------------------------------#

>>> book = Book("Fahrenheit 451", "Bradbury")
>>> book.title = "1984"
dataclasses.FrozenInstanceError: cannot assign to field 'title'
```

### ****Наследование****

Когда вы используете декоратор `@dataclass`, он проходит по всем родительским классам начиная с object и для каждого найденного класса данных сохраняет поля в упорядоченный словарь *(ordered mapping)*, затем добавляя свойства обрабатываемого класса. Все сгенерированные методы используют поля из полученного упорядоченного словаря.

Как следствие, если родительский класс определяет значения по умолчанию, вы должны будете поля определять со значениями по умолчанию.

Так как упорядоченный словарь хранит значения в порядке вставки, то для следующих классов будет сгенерирован `__init__` метод с такой сигнатурой:

```python
@dataclass
class BaseBook:
    title: Any = None
    author: str = None

@dataclass
class Book(BaseBook):
    desc: str = None
    title: str = "Unknown"

#------------------------------------------------------------------------#

def __init__(self, title: str="Unknown", author: str=None, desc: str=None)
```